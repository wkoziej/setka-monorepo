# YAML Configuration Migration Specification

## Overview

This specification outlines the migration from environment variable-based configuration to YAML configuration files for the cinemon compositional animation system, with support for selective strip targeting.

## Current State Analysis

### Environment Variables Currently Used
From analysis of `config.py` and usage throughout the codebase:

**Core Configuration:**
- `BLENDER_VSE_VIDEO_FILES` - Comma-separated list of video file paths
- `BLENDER_VSE_MAIN_AUDIO` - Main audio file path
- `BLENDER_VSE_OUTPUT_BLEND` - Output .blend file path
- `BLENDER_VSE_RENDER_OUTPUT` - Render output path
- `BLENDER_VSE_FPS` - Frame rate (default: 30)
- `BLENDER_VSE_RESOLUTION_X` - Width (default: 1920)
- `BLENDER_VSE_RESOLUTION_Y` - Height (default: 1080)
- `BLENDER_VSE_ANIMATION_MODE` - Animation mode (none, beat-switch, energy-pulse, multi-pip, compositional)
- `BLENDER_VSE_BEAT_DIVISION` - Beat division for analysis (default: 8)

**Audio Analysis:**
- `BLENDER_VSE_AUDIO_ANALYSIS_FILE` - Path to analysis JSON file
- `BLENDER_VSE_AUDIO_ANALYSIS` - Direct JSON string

**Compositional Animation (new system):**
- `BLENDER_VSE_LAYOUT_TYPE` - Layout type (random, grid, center, fill)
- `BLENDER_VSE_LAYOUT_CONFIG` - Layout parameters string
- `BLENDER_VSE_ANIMATION_CONFIG` - Animation chain configuration

### Current Integration Points

**Fermata Integration:**
- Uses CLI: `uv run --package cinemon cinemon-blend-setup`
- Passes parameters via CLI args: `--animation-mode beat-switch --main-audio "audio.m4a"`
- Hardcoded to `beat-switch` animation mode
- No environment variable usage in fermata

**CLI Interface:**
- `cinemon-blend-setup ./recording --animation-mode MODE`
- Optional `--main-audio` parameter
- All other parameters via environment variables

## Target YAML Configuration Structure

### File Location
- **Path**: `{recording_directory}/animation_config.yaml`
- **Generated by**: Client calling cinemon (fermata, direct CLI usage)
- **Validated by**: cinemon on startup (fail-fast approach)

### YAML Schema

```yaml
# Core project configuration
project:
  video_files: [Camera1.mp4, Camera2.mp4, Camera3.mp4]
  main_audio: "Przechwytywanie wejścia dźwięku (PulseAudio).m4a"
  output_blend: blender/project.blend
  render_output: blender/render/output.mp4
  fps: 30
  resolution:
    width: 1920
    height: 1080
  beat_division: 8

# Audio analysis configuration
audio_analysis:
  file: analysis/audio_analysis.json
  # Optional: inline JSON data as fallback
  data: null

# Layout configuration
layout:
  type: random  # random, grid, center, fill
  config:
    # Random layout specific
    overlap_allowed: false
    seed: 42
    margin: 0.05
    min_scale: 0.4
    max_scale: 0.8
    # Grid layout specific (for future)
    # rows: 2
    # cols: 2
    # spacing: 0.1
    # Center layout specific (for future)
    # scale: 1.0
    # Fill layout specific (for future)
    # arrangement: auto  # auto, horizontal, vertical

# Animation configuration with selective targeting
animations:
  - type: scale
    trigger: bass
    intensity: 0.3
    duration_frames: 2
    target_strips: [Camera1, Camera2]

  - type: vintage_color
    trigger: one_time
    sepia_amount: 0.4
    contrast_boost: 0.3
    target_strips: [Camera3]

  - type: shake
    trigger: beat
    intensity: 5.0
    return_frames: 2
    target_strips: [Camera4, Camera5]
```

### Animation Types and Parameters

**Scale Animation:**
```yaml
- type: scale
  trigger: bass|beat|energy_peaks
  intensity: 0.3        # Scale increase factor
  duration_frames: 2    # Animation duration
  target_strips: [...]  # Strip names
```

**Shake Animation:**
```yaml
- type: shake
  trigger: beat|bass|energy_peaks
  intensity: 5.0        # Shake distance in pixels
  return_frames: 2      # Frames to return to original position
  target_strips: [...]
```

**Rotation Animation:**
```yaml
- type: rotation
  trigger: beat|bass|energy_peaks
  degrees: 1.5          # Maximum rotation degrees
  return_frames: 4      # Frames to return to 0 rotation
  target_strips: [...]
```

**Vintage Effects:**
```yaml
- type: vintage_color
  trigger: one_time
  sepia_amount: 0.4     # Sepia tint intensity (0.0-1.0)
  contrast_boost: 0.3   # Contrast increase (0.0-1.0)
  target_strips: [...]

- type: film_grain
  trigger: one_time
  intensity: 0.15       # Grain intensity (0.0-1.0)
  target_strips: [...]

- type: black_white
  trigger: one_time
  intensity: 0.8        # Desaturation intensity (0.0-1.0)
  target_strips: [...]
```

**Continuous Effects:**
```yaml
- type: jitter
  trigger: continuous
  intensity: 2.0        # Jitter distance in pixels
  min_interval: 3       # Minimum frames between changes
  max_interval: 8       # Maximum frames between changes
  target_strips: [...]

- type: brightness_flicker
  trigger: beat|bass|energy_peaks
  intensity: 0.15       # Brightness reduction (0.0-1.0)
  return_frames: 1      # Frames to return to normal
  target_strips: [...]
```

## Implementation Plan

### Phase 1: YAML Configuration Support

#### 1.1 Create YAML Configuration Classes in setka-common
```python
# setka-common/src/setka_common/config/yaml_config.py
from dataclasses import dataclass
from typing import List, Optional, Dict, Any
import yaml
from pathlib import Path

@dataclass
class ProjectConfig:
    video_files: List[str]
    main_audio: Optional[str] = None
    output_blend: Optional[str] = None
    render_output: Optional[str] = None
    fps: int = 30
    resolution: Dict[str, int] = None
    beat_division: int = 8

@dataclass
class AudioAnalysisConfig:
    file: Optional[str] = None
    data: Optional[Dict[str, Any]] = None

@dataclass
class LayoutConfig:
    type: str = "random"
    config: Dict[str, Any] = None

@dataclass
class AnimationSpec:
    type: str
    trigger: str
    target_strips: List[str]
    # Dynamic parameters based on animation type
    **kwargs

@dataclass
class BlenderYAMLConfig:
    project: ProjectConfig
    audio_analysis: AudioAnalysisConfig
    layout: LayoutConfig
    animations: List[AnimationSpec]

class YAMLConfigLoader:
    def load_config(self, config_path: Path) -> BlenderYAMLConfig:
        """Load and validate YAML configuration."""

    def validate_config(self, config: BlenderYAMLConfig) -> Tuple[bool, List[str]]:
        """Validate configuration with fail-fast approach."""

    def convert_to_env_vars(self, config: BlenderYAMLConfig) -> Dict[str, str]:
        """Convert YAML config to environment variables for backwards compatibility."""
```

#### 1.2 Create setka-common config module structure
```python
# setka-common/src/setka_common/config/__init__.py
from .yaml_config import BlenderYAMLConfig, AnimationSpec, YAMLConfigLoader
from .validation import ConfigValidator

__all__ = ["BlenderYAMLConfig", "AnimationSpec", "YAMLConfigLoader", "ConfigValidator"]

# setka-common/src/setka_common/config/validation.py
from typing import List, Tuple
from pathlib import Path

class ConfigValidator:
    """Shared validation utilities for configuration files."""

    def validate_file_exists(self, path: Path) -> bool:
        """Validate that a file exists."""

    def validate_range(self, value: float, min_val: float, max_val: float) -> bool:
        """Validate that a value is within range."""

    def validate_strip_targeting(self, target_strips: List[str], available_strips: List[str]) -> List[str]:
        """Validate that target strips exist in available strips."""

# setka-common/src/setka_common/__init__.py
# Main package entry point for easy importing
from .config import BlenderYAMLConfig, AnimationSpec, YAMLConfigLoader
from .file_structure.specialized import RecordingStructureManager

__all__ = ["BlenderYAMLConfig", "AnimationSpec", "YAMLConfigLoader", "RecordingStructureManager"]
```

#### 1.3 Modify CLI Interface
```python
# src/blender/cli/blend_setup.py
from setka_common.config import BlenderYAMLConfig, YAMLConfigLoader

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("recording_dir", type=Path)
    parser.add_argument("--config", type=Path, help="YAML configuration file")

    args = parser.parse_args()

    # Load YAML config
    config_path = args.config
    if not config_path.exists():
        raise FileNotFoundError(f"Configuration file not found: {config_path}")

    config = YAMLConfigLoader().load_config(config_path)

    # Validate configuration (fail-fast)
    is_valid, errors = YAMLConfigLoader().validate_config(config)
    if not is_valid:
        print(f"Configuration validation failed:")
        for error in errors:
            print(f"  - {error}")
        sys.exit(1)

    # Convert to environment variables for Blender script
    env_vars = YAMLConfigLoader().convert_to_env_vars(config)

    # Run Blender with environment
    manager = BlenderProjectManager()
    manager.create_vse_project_with_config(args.recording_dir, config)
```

#### 1.4 Update Animation System for Strip Targeting
```python
# src/blender/vse/animation_compositor.py
class AnimationCompositor:
    def apply(self, video_strips: List, audio_analysis: Dict, fps: int) -> bool:
        """Apply layout and targeted animations to strips."""
        try:
            # Apply layout to all strips
            resolution = self._get_scene_resolution()
            positions = self.layout.calculate_positions(len(video_strips), resolution)
            self._apply_layout(video_strips, positions)

            # Apply animations with strip targeting
            for animation in self.animations:
                events = self._extract_events(audio_analysis, animation.trigger)
                if events:
                    target_strips = self._filter_strips_for_animation(video_strips, animation)
                    for strip in target_strips:
                        animation.apply_to_strip(strip, events, fps)

            return True
        except Exception as e:
            print(f"Error applying compositor: {e}")
            return False

    def _filter_strips_for_animation(self, video_strips: List, animation) -> List:
        """Filter strips based on animation targeting."""
        if not animation.target_strips:
            return video_strips  # No targeting = apply to all

        filtered_strips = []
        for strip in video_strips:
            strip_name = self._get_strip_name(strip)
            if strip_name in animation.target_strips:
                filtered_strips.append(strip)

        return filtered_strips

    def _get_strip_name(self, strip) -> str:
        """Extract strip name from video file path."""
        # Extract filename without extension from strip.filepath
        return Path(strip.filepath).stem
```

### Phase 2: Fermata Integration Changes

#### 2.1 Configuration Generator Module
```python
# New module: src/blender/config_generator.py
from setka_common.config import BlenderYAMLConfig, AnimationSpec, YAMLConfigLoader

class CinemonConfigGenerator:
    """Generates YAML configuration for cinemon from high-level parameters."""

    def generate_config(self,
                       recording_dir: Path,
                       animation_mode: str = "beat-switch",
                       main_audio: Optional[str] = None,
                       custom_animations: Optional[List[Dict]] = None) -> Path:
        """Generate YAML config file in recording directory."""

        config_path = recording_dir / "animation_config.yaml"

        # Discover video files
        video_files = self._discover_video_files(recording_dir)

        # Create configuration
        if animation_mode == "beat-switch":
            config = self._create_beat_switch_config(video_files, main_audio)
        elif animation_mode == "compositional":
            config = self._create_compositional_config(video_files, main_audio, custom_animations)
        else:
            config = self._create_legacy_config(video_files, main_audio, animation_mode)

        # Write YAML file
        with open(config_path, 'w') as f:
            yaml.dump(config, f, default_flow_style=False)

        return config_path

    def _create_beat_switch_config(self, video_files: List[str], main_audio: Optional[str]) -> Dict:
        """Create configuration for beat-switch animation (all strips)."""
        return {
            'project': {
                'video_files': video_files,
                'main_audio': main_audio,
                'output_blend': 'blender/project.blend',
                'render_output': 'blender/render/output.mp4',
                'fps': 30,
                'resolution': {'width': 1920, 'height': 1080},
                'beat_division': 8
            },
            'audio_analysis': {
                'file': 'analysis/audio_analysis.json'
            },
            'layout': {
                'type': 'random',
                'config': {
                    'overlap_allowed': False,
                    'seed': 42,
                    'margin': 0.05,
                    'min_scale': 0.6,
                    'max_scale': 0.9
                }
            },
            'animations': [
                {
                    'type': 'scale',
                    'trigger': 'beat',
                    'intensity': 0.2,
                    'duration_frames': 2,
                    'target_strips': video_files  # All strips
                }
            ]
        }
```

#### 2.2 Fermata ProcessRunner Changes
```rust
// src-tauri/src/services/process_runner.rs
impl ProcessRunner {
    /// Generate config and run cinemon render
    pub async fn run_cinemon_render(&self, recording_path: &Path, animation_mode: &str) -> anyhow::Result<ProcessResult> {
        // Generate YAML config
        let config_path = self.generate_cinemon_config(recording_path, animation_mode, None).await?;

        // Run cinemon with config
        let mut cmd = Command::new("uv");
        cmd.args(&["run", "--package", "cinemon", "cinemon-blend-setup"])
            .arg(recording_path)
            .args(&["--config", &config_path.to_string_lossy()]);

        self.run_command(cmd).await
    }

    /// Generate config and run cinemon render with main audio
    pub async fn run_cinemon_render_with_audio(&self, recording_path: &Path, animation_mode: &str, main_audio: Option<&str>) -> anyhow::Result<ProcessResult> {
        // Generate YAML config
        let config_path = self.generate_cinemon_config(recording_path, animation_mode, main_audio).await?;

        // Run cinemon with config
        let mut cmd = Command::new("uv");
        cmd.args(&["run", "--package", "cinemon", "cinemon-blend-setup"])
            .arg(recording_path)
            .args(&["--config", &config_path.to_string_lossy()]);

        self.run_command(cmd).await
    }

    /// Generate YAML configuration for cinemon
    async fn generate_cinemon_config(&self, recording_path: &Path, animation_mode: &str, main_audio: Option<&str>) -> anyhow::Result<PathBuf> {
        // Call Python config generator
        let mut cmd = Command::new("uv");
        cmd.args(&["run", "--package", "cinemon", "python", "-c"])
            .arg(&format!(
                "from blender.config_generator import CinemonConfigGenerator; \
                 gen = CinemonConfigGenerator(); \
                 print(gen.generate_config('{}', '{}', {}))",
                recording_path.to_string_lossy(),
                animation_mode,
                main_audio.map(|a| format!("'{}'", a)).unwrap_or_else(|| "None".to_string())
            ));

        let output = cmd.output().await?;
        let config_path = String::from_utf8(output.stdout)?.trim().to_string();

        Ok(PathBuf::from(config_path))
    }
}
```

### Phase 3: Remove Environment Variable Support

#### 3.1 Complete Removal
- Remove all `os.getenv()` calls from `config.py`
- Remove `BlenderVSEConfig` class
- Update all tests to use YAML config
- Remove environment variable documentation

#### 3.2 Update Documentation
- Update `CLAUDE.md` with new configuration approach
- Update examples in `compositional-animation-examples.md`
- Update fermata integration documentation

## Migration Strategy

### Step 1: Implement YAML Support (Week 1)
- Create YAML configuration classes and loader
- Add `--config` parameter to CLI
- Maintain environment variable support temporarily

### Step 2: Update Fermata Integration (Week 1-2)
- Create configuration generator module
- Update ProcessRunner to generate YAML configs
- Test fermata → cinemon pipeline

### Step 3: Remove Environment Variables (Week 2)
- Remove all environment variable code
- Update all tests
- Update documentation

### Step 4: Add Advanced Features (Week 3)
- Implement selective strip targeting
- Add configuration validation
- Add error handling improvements

## Validation Strategy

### Configuration Validation Rules
1. **Required fields**: project.video_files, layout.type
2. **File existence**: All video files, audio files must exist
3. **Value ranges**: intensities (0.0-1.0), FPS > 0, resolution > 0
4. **Strip targeting**: target_strips must match existing video file names
5. **Animation parameters**: Each animation type has specific required parameters

### Error Handling
- **Fail-fast approach**: Stop execution on first validation error
- **Clear error messages**: Specify exact field and expected value
- **Path validation**: Ensure all paths are accessible and correct

## Benefits

1. **No length limitations**: YAML files can be any size
2. **Proper type safety**: YAML supports proper data types
3. **Self-documenting**: Clear structure and comments
4. **IDE support**: Syntax highlighting and validation
5. **Extensible**: Easy to add new configuration options
6. **Selective targeting**: Different animations for different strips
7. **Maintainable**: Clean separation of concerns
8. **Version control friendly**: Text-based configuration

## Risks and Mitigation

### Risk 1: Configuration Complexity
- **Mitigation**: Provide configuration generator and templates
- **Mitigation**: Good documentation and examples

### Risk 2: YAML Parsing Errors
- **Mitigation**: Comprehensive validation with clear error messages
- **Mitigation**: Schema validation

### Risk 3: Integration Complexity
- **Mitigation**: Phase implementation approach
- **Mitigation**: Maintain thorough test coverage

## Success Criteria

1. **Complete removal** of environment variable usage
2. **Successful fermata integration** with YAML configuration
3. **Selective animation targeting** works correctly
4. **Configuration validation** provides clear error messages
5. **All tests pass** with new configuration system
6. **Documentation updated** with new examples

## Timeline

- **Week 1**: YAML configuration implementation and CLI updates
- **Week 2**: Fermata integration and environment variable removal
- **Week 3**: Advanced features and documentation updates

This specification provides a complete roadmap for migrating from environment variables to YAML configuration while adding selective strip targeting capabilities.
